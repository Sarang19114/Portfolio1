"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[442],{8442:(e,n,o)=>{o.r(n),o.d(n,{default:()=>c});var t=o(7876),i=o(4232),r=o(8492),a=o(1428),l=o(8337),s=o(6771),v=o(5592);let c=e=>{let{className:n=""}=e,o=(0,i.useRef)(null),c=(0,i.useRef)(null),u=(0,i.useRef)(null),d=(0,i.useRef)({x:0,y:0}),f=(0,i.useRef)(!1),{ref:m,isInView:x}=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{rootMargin:n="200px",threshold:o=.01,triggerOnce:t=!1,unmountWhenHidden:r=!1}=e,a=(0,i.useRef)(null),[l,s]=(0,i.useState)(!1),[v,c]=(0,i.useState)(!1);return(0,i.useEffect)(()=>{let e=a.current;if(!e)return;if(t&&v)return void s(!0);let i=new IntersectionObserver(e=>{let[n]=e,o=n.isIntersecting;s(o),o&&!v&&c(!0),t&&o&&i.disconnect()},{rootMargin:n,threshold:o});return i.observe(e),()=>{i.disconnect()}},[n,o,t,v]),{ref:a,isInView:l,hasBeenInView:v,shouldRender:!r||l||!v}}({rootMargin:"0px",threshold:.01,triggerOnce:!1});return(0,i.useEffect)(()=>{let e=o.current;if(!e)return;let n=Math.PI/3,t=new r.Z58;t.fog=new r.cRK(131332,.025);let i=new r.ubm(60,window.innerWidth/window.innerHeight,.1,4e3),m={x:-6.5,y:5,z:6.5};i.position.set(m.x,m.y,m.z);let p=new r.JeP({antialias:!0,powerPreference:"high-performance",alpha:!0});p.setSize(window.innerWidth,window.innerHeight),p.setPixelRatio(Math.min(window.devicePixelRatio,1.5)),p.outputColorSpace=r.er$,p.toneMapping=r.FV,p.toneMappingExposure=1.8,p.setClearColor(0,.1),e.appendChild(p.domElement);let w=new a.s(p);w.addPass(new l.A(t,i));let h=new s.C(new r.I9Y(window.innerWidth,window.innerHeight),1.2,.4,.9);w.addPass(h);let g={uniforms:{tDiffuse:{value:null},blackHoleScreenPos:{value:new r.I9Y(.5,.5)},lensingStrength:{value:.12},lensingRadius:{value:.3},aspectRatio:{value:window.innerWidth/window.innerHeight},chromaticAberration:{value:.005}},vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:"\n            uniform sampler2D tDiffuse;\n            uniform vec2 blackHoleScreenPos;\n            uniform float lensingStrength;\n            uniform float lensingRadius;\n            uniform float aspectRatio;\n            uniform float chromaticAberration;\n            varying vec2 vUv;\n            \n            void main() {\n                vec2 screenPos = vUv;\n                vec2 toCenter = screenPos - blackHoleScreenPos;\n                toCenter.x *= aspectRatio;\n                float dist = length(toCenter);\n                \n                float distortionAmount = lensingStrength / (dist * dist + 0.003);\n                distortionAmount = clamp(distortionAmount, 0.0, 0.7);\n                float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist);\n                distortionAmount *= falloff;\n                \n                vec2 offset = normalize(toCenter) * distortionAmount;\n                offset.x /= aspectRatio;\n                \n                vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration);\n                vec2 distortedUvG = screenPos - offset;\n                vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration);\n                \n                float r = texture2D(tDiffuse, distortedUvR).r;\n                float g = texture2D(tDiffuse, distortedUvG).g;\n                float b = texture2D(tDiffuse, distortedUvB).b;\n                \n                gl_FragColor = vec4(r, g, b, 1.0);\n            }"},y=new v.p(g);w.addPass(y);let z=new r.LoY,C=new Float32Array(45e4),b=new Float32Array(45e4),P=new Float32Array(15e4),R=new Float32Array(15e4),M=[new r.Q1f(8956671),new r.Q1f(0xffaaff),new r.Q1f(0xaaffff),new r.Q1f(0xffddaa),new r.Q1f(0xffeecc),new r.Q1f(0xffffff),new r.Q1f(0xff8888),new r.Q1f(8978312),new r.Q1f(0xffff88),new r.Q1f(8978431)];for(let e=0;e<15e4;e++){let n=3*e,o=Math.acos(-1+2*e/15e4),t=Math.sqrt(15e4*Math.PI)*o,i=2e3*Math.cbrt(Math.random())+100;C[n]=i*Math.sin(o)*Math.cos(t),C[n+1]=i*Math.sin(o)*Math.sin(t),C[n+2]=i*Math.cos(o);let a=M[Math.floor(Math.random()*M.length)].clone();a.multiplyScalar(.7*Math.random()+.3),b[n]=a.r,b[n+1]=a.g,b[n+2]=a.b,P[e]=r.cj9.randFloat(.6,3),R[e]=Math.random()*Math.PI*2}z.setAttribute("position",new r.THS(C,3)),z.setAttribute("color",new r.THS(b,3)),z.setAttribute("size",new r.THS(P,1)),z.setAttribute("twinkle",new r.THS(R,1));let S=new r.BKk({uniforms:{uTime:{value:0},uPixelRatio:{value:p.getPixelRatio()}},vertexShader:"\n            uniform float uTime;\n            uniform float uPixelRatio;\n            attribute float size;\n            attribute float twinkle;\n            varying vec3 vColor;\n            varying float vTwinkle;\n            \n            void main() {\n                vColor = color;\n                vTwinkle = sin(uTime * 2.5 + twinkle) * 0.5 + 0.5;\n                \n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z);\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            varying vec3 vColor;\n            varying float vTwinkle;\n            \n            void main() {\n                float dist = distance(gl_PointCoord, vec2(0.5));\n                if (dist > 0.5) discard;\n                \n                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n                alpha *= (0.2 + vTwinkle * 0.8);\n                \n                gl_FragColor = vec4(vColor, alpha);\n            }\n        ",transparent:!0,vertexColors:!0,blending:r.EZo,depthWrite:!1}),T=new r.ONl(z,S);t.add(T);let k=new r.Gu$(1.3650000000000002,128,64),A=new r.BKk({uniforms:{uTime:{value:0},uCameraPosition:{value:i.position}},vertexShader:"\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            void main() {\n                vNormal = normalize(normalMatrix * normal);\n                vPosition = position;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",fragmentShader:"\n            uniform float uTime;\n            uniform vec3 uCameraPosition;\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            \n            void main() {\n                vec3 viewDirection = normalize(uCameraPosition - vPosition);\n                float fresnel = 1.0 - abs(dot(vNormal, viewDirection));\n                fresnel = pow(fresnel, 2.5);\n                \n                vec3 glowColor = vec3(1.0, 0.4, 0.1);\n                float pulse = sin(uTime * 2.5) * 0.15 + 0.85;\n                \n                gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.4);\n            }\n        ",transparent:!0,blending:r.EZo,side:r.hsX}),_=new r.eaF(k,A);t.add(_);let D=new r.Gu$(1.3,128,64),F=new r.V9B({color:0}),U=new r.eaF(D,F);U.renderOrder=0,t.add(U);let V=new r.rKP(1.5,8,256,128),E=new r.BKk({uniforms:{uTime:{value:0},uColorHot:{value:new r.Q1f(0xffffff)},uColorMid1:{value:new r.Q1f(0xff7733)},uColorMid2:{value:new r.Q1f(0xff4477)},uColorMid3:{value:new r.Q1f(7816447)},uColorOuter:{value:new r.Q1f(4487167)},uNoiseScale:{value:2.5},uFlowSpeed:{value:.22},uDensity:{value:1.3}},vertexShader:"\n            varying vec2 vUv;\n            varying float vRadius;\n            varying float vAngle;\n            void main() {\n                vUv = uv;\n                vRadius = length(position.xy);\n                vAngle = atan(position.y, position.x);\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",fragmentShader:"\n            uniform float uTime;\n            uniform vec3 uColorHot;\n            uniform vec3 uColorMid1;\n            uniform vec3 uColorMid2;\n            uniform vec3 uColorMid3;\n            uniform vec3 uColorOuter;\n            uniform float uNoiseScale;\n            uniform float uFlowSpeed;\n            uniform float uDensity;\n\n            varying vec2 vUv;\n            varying float vRadius;\n            varying float vAngle;\n\n            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n            \n            float snoise(vec3 v) {\n                const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n                vec3 i  = floor(v + dot(v, C.yyy) );\n                vec3 x0 = v - i + dot(i, C.xxx) ;\n                vec3 g = step(x0.yzx, x0.xyz);\n                vec3 l = 1.0 - g;\n                vec3 i1 = min( g.xyz, l.zxy );\n                vec3 i2 = max( g.xyz, l.zxy );\n                vec3 x1 = x0 - i1 + C.xxx;\n                vec3 x2 = x0 - i2 + C.yyy;\n                vec3 x3 = x0 - D.yyy;\n                i = mod289(i);\n                vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                       + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n                float n_ = 0.142857142857;\n                vec3  ns = n_ * D.wyz - D.xzx;\n                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n                vec4 x_ = floor(j * ns.z);\n                vec4 y_ = floor(j - 7.0 * x_ );\n                vec4 x = x_ *ns.x + ns.yyyy;\n                vec4 y = y_ *ns.x + ns.yyyy;\n                vec4 h = 1.0 - abs(x) - abs(y);\n                vec4 b0 = vec4( x.xy, y.xy );\n                vec4 b1 = vec4( x.zw, y.zw );\n                vec4 s0 = floor(b0)*2.0 + 1.0;\n                vec4 s1 = floor(b1)*2.0 + 1.0;\n                vec4 sh = -step(h, vec4(0.0));\n                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n                vec3 p0 = vec3(a0.xy,h.x);\n                vec3 p1 = vec3(a0.zw,h.y);\n                vec3 p2 = vec3(a1.xy,h.z);\n                vec3 p3 = vec3(a1.zw,h.w);\n                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;\n                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n            }\n\n            void main() {\n                float normalizedRadius = smoothstep(".concat("1.50",", ").concat("8.00",", vRadius);\n                \n                float spiral = vAngle * 3.0 - (1.0 / (normalizedRadius + 0.1)) * 2.0;\n                vec2 noiseUv = vec2(vUv.x + uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0)) + sin(spiral) * 0.1, vUv.y * 0.8 + cos(spiral) * 0.1);\n                float noiseVal1 = snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15));\n                float noiseVal2 = snoise(vec3(noiseUv * uNoiseScale * 3.0 + 0.8, uTime * 0.22));\n                float noiseVal3 = snoise(vec3(noiseUv * uNoiseScale * 6.0 + 1.5, uTime * 0.3));\n                \n                float noiseVal = (noiseVal1 * 0.45 + noiseVal2 * 0.35 + noiseVal3 * 0.2);\n                noiseVal = (noiseVal + 1.0) * 0.5;\n                \n                vec3 color = uColorOuter;\n                color = mix(color, uColorMid3, smoothstep(0.0, 0.25, normalizedRadius));\n                color = mix(color, uColorMid2, smoothstep(0.2, 0.55, normalizedRadius));\n                color = mix(color, uColorMid1, smoothstep(0.5, 0.75, normalizedRadius));\n                color = mix(color, uColorHot, smoothstep(0.7, 0.95, normalizedRadius));\n                \n                color *= (0.5 + noiseVal * 1.0);\n                float brightness = pow(1.0 - normalizedRadius, 1.0) * 3.5 + 0.5;\n                brightness *= (0.3 + noiseVal * 2.2);\n                \n                float pulse = sin(uTime * 1.8 + normalizedRadius * 12.0 + vAngle * 2.0) * 0.15 + 0.85;\n                brightness *= pulse;\n                \n                float alpha = uDensity * (0.2 + noiseVal * 0.9);\n                alpha *= smoothstep(0.0, 0.15, normalizedRadius);\n                alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius));\n                alpha = clamp(alpha, 0.0, 1.0);\n\n                gl_FragColor = vec4(color * brightness, alpha);\n            }\n        "),transparent:!0,side:r.$EB,depthWrite:!1,blending:r.EZo}),H=new r.eaF(V,E);H.rotation.x=n,H.renderOrder=1,t.add(H);let Q=new r.zD7,N=new r.Pq0,j=n=>{let o=e.getBoundingClientRect();d.current.x=(n.clientX-o.left)/o.width*2-1,d.current.y=-(2*((n.clientY-o.top)/o.height))+1},I=()=>{c.current&&clearTimeout(c.current),c.current=setTimeout(()=>{let e=window.innerWidth,n=window.innerHeight;i.aspect=e/n,i.updateProjectionMatrix(),p.setSize(e,n),w.setSize(e,n),h.resolution.set(e,n),y.uniforms.aspectRatio.value=e/n,p.setPixelRatio(Math.min(window.devicePixelRatio,1.5))},150)},B=()=>{if(u.current=requestAnimationFrame(B),!x||f.current)return;let e=Q.getElapsedTime(),n=Q.getDelta();E.uniforms.uTime.value=e,S.uniforms.uTime.value=e,A.uniforms.uTime.value=e,A.uniforms.uCameraPosition.value.copy(i.position),N.copy(U.position).project(i),y.uniforms.blackHoleScreenPos.value.set((N.x+1)/2,(N.y+1)/2),i.position.x=m.x+.5*d.current.x,i.position.y=m.y+.5*d.current.y*.5,i.position.z=m.z+.5*d.current.y*.3,i.lookAt(0,0,0),T.rotation.y+=.003*n,T.rotation.x+=.001*n,H.rotation.z+=.005*n,w.render()};return window.addEventListener("resize",I),window.addEventListener("mousemove",j),B(),()=>{u.current&&cancelAnimationFrame(u.current),window.removeEventListener("resize",I),window.removeEventListener("mousemove",j),c.current&&clearTimeout(c.current),e&&p.domElement.parentNode===e&&e.removeChild(p.domElement),p.dispose()}},[x]),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("style",{children:"\n        .blackhole-background {\n          position: fixed;\n          top: 0;\n          left: 0;\n          width: 100vw;\n          height: 100vh;\n          z-index: 0;\n          pointer-events: none;\n        }\n        .blackhole-background canvas {\n          display: block;\n          width: 100% !important;\n          height: 100% !important;\n          opacity: 0.8;\n        }\n      "}),(0,t.jsx)("div",{className:"blackhole-background ".concat(n),ref:e=>{o.current=e,m.current=e}})]})}}}]);